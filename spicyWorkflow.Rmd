---
title: "Performing a spatial analysis of multiplexed tissue imaging data."
author: "Alexander Nicholls and Ellis Patrick"
date: '2022-07-11'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, message = FALSE, warning = FALSE, cache.lazy = FALSE)
```


```{r message=FALSE}
library(cytomapper)
library(dplyr)
library(ggplot2)
library(simpleSeg)
library(FuseSOM)
library(ggpubr)
library(scater)
library(spicyR)
#library(ClassifyR)
library(ClassifyR, lib.loc = "~/localPackages/")
library(scFeatures)
library(lisaClust)

theme_set(theme_classic())
#withr::with_libpaths(new = "~/localPackages/", devtools::install_github("SydneyBioX/ClassifyR"))

```
# Global paramaters
```{r}
nCores <- 20
BPPARAM <- simpleSeg:::generateBPParam(nCores)

```



# Read in images

Our images are stored in the `images` folder within the `Data` folder. Here we use `readImages()` from the `EBImage` package to read these into R. If memory is a restricting factor, and the files are in a slightly different format, you could use `loadImages()` from the `cytomapper` package to load all of the tiff images into a `CytoImageList` object, which can store the images as h5 on-disk.


```{r}

pathToImages <- "Data/images"

# Get directories of images
imageDirs <- dir(pathToImages, full.names = TRUE)
names(imageDirs) <- dir(pathToImages, full.names = FALSE)

# Get files in each directory
files <- sapply(imageDirs, list.files, pattern = "tif", full.names = TRUE, simplify = FALSE)

# Read files with readImage from EBImage
images <- lapply(files, EBImage::readImage, as.is = TRUE)

```

We will make use of the `on_disk` option to convert our images to a `CytoImageList` with the images not held in memory.

```{r}



# Store images in a CytoImageList with images on_disk as h5 files to save memory. 
dir.create("Data/h5Files")
images <- cytomapper::CytoImageList(images, 
                                    on_disk = TRUE, 
                                    h5FilesPath = "Data/h5Files", 
                                    BPPARAM = BPPARAM)
gc()

# images <- cytomapper::loadImages("Data/h5Files/", pattern = "h5", h5FilesPath = "Data/h5Files/",on_disk = TRUE)
# mcols(images) <- S4Vectors::DataFrame(imageID = names(images))
```

# Load the clinical data

## Read the clinical data
```{r}
# Read in clinical data, manipulate imageID and select columns
clinical <- read.csv("Data/1-s2.0-S0092867421014860-mmc1.csv")
clinical <- clinical |>
  mutate(imageID = paste0("Point", PointNumber, "_pt", Patient_ID, "_", TMAD_Patient))
clinical$imageID[grep("normal", clinical$Tissue_Type)] <- paste0(clinical$imageID[grep("normal", clinical$Tissue_Type)], "_Normal")

clinicalVariables <- c("imageID", "Patient_ID","Status", "Age", "SUBTYPE", "PAM50", "Treatment", "DCIS_grade", "Necrosis")
rownames(clinical) <- clinical$imageID

```


## Put the clinical data into the colData of SingleCellExperiment
```{r}
# Add the clinical data to mcols of images.
mcols(images) <- clinical[names(images), clinicalVariables]

```






# Segment the images

## Run simpleSeg
```{r}
# Generate segmentation masks 
masks <- simpleSeg(images,
                   nucleus = c("PCA", "HH3"),
                   cellBody = "dilate",
                   transform = "sqrt",
                   sizeSelection = 40,
                   discSize = 2,
                   cores = nCores)

```


## Visualise separation

```{r}
# Visualise segmentation performance one way.
EBImage::display(colorLabels(masks[[1]]))

```

## Visualise outlines

```{r}
# Visualise segmentation performance another way.
cytomapper::plotPixels(image = images[1], 
                       mask = masks[1], 
                       img_id = "imageID", 
                       colour_by = c("PanKRT", "GLUT1", "HH3", "CD3", "CD20"), 
                       display = "single",
                       colour = list(HH3 = c("black","blue"), 
                                     CD3 = c("black","purple"),
                                     CD20 = c("black","green"),
                                     GLUT1 = c("black", "red"),
                                     PanKRT = c("black", "yellow")),
                       bcg = list(HH3 = c(0, 1, 1.5), 
                                     CD3 = c(0, 1, 1.5),
                                     CD20 = c(0, 1, 1.5),
                                     GLUT1 = c(0, 1, 1.5),
                                     PanKRT = c(0, 1, 1.5)),
                       legend = NULL)


```


# Summarise cell features.

```{r}
# Summarise the experssion of each marker in each cell
cells <- cytomapper::measureObjects(masks, 
                                    images, 
                                    img_id = "imageID", 
                                    BPPARAM = BPPARAM)

```






# Normalize data


```{r, fig.width=5, fig.height=5}

# Extract marker data and bind with information about images
df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))

# Plots densities of PanKRT for each image.
ggplot(df, aes(x = PanKRT, colour = imageID)) + 
  geom_density() + 
  theme(legend.position = "none")

```



```{r, fig.width=5, fig.height=5}
# Transform and normalise the marker expression of each cell type.
# Use a square root transform, then trimmed the 99 quantile 
cells <- normalizeCells(cells, 
                        transformation = "sqrt", 
                        method = c("trim99", "minMax"), 
                        assayIn = "counts", 
                        cores = nCores)

# Extract normalised marker information.
df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))

# Plots densities of normalised PanKRT for each image.
ggplot(df, aes(x = PanKRT, colour = imageID)) + 
  geom_density() + 
  theme(legend.position = "none")

```



# Cluster cells using FuseSOM package

## Perform the clustering
```{r}
# The markers used in the original publication to gate cell types.
useMarkers <- c("PanKRT", "ECAD", "CK7", "VIM", "FAP", "CD31", "CK5", "SMA", 
                "CD45", "CD4", "CD3", "CD8", "CD20", "CD68", "CD14", "CD11c", 
                "HLADRDPDQ", "MPO", "Tryptase")

# Set seed.
set.seed(51773)

# Generate SOM and cluster cells into 20 groups.
cells <- runFuseSOM(cells, 
                    markers = useMarkers, 
                    assay = 'norm', 
                    numClusters = 20)

```



## Check how many clusters should be used.
```{r}

# Generate metrics for estimating the number of clusters.
# As I've already run runFuseSOM I don't need to run generateSOM().
cells <- estimateNumCluster(cells, kseq = 2:30)
optiPlot(cells, method = "gap")


```


```{r}
# Visualise marker expression in each cluster.
scater::plotGroupedHeatmap(cells, 
                           features = useMarkers, 
                           group = "clusters", 
                           exprs_values = "norm",
                           center = TRUE, 
                           scale = TRUE, 
                           zlim = c(-3,3),
                           cluster_rows = FALSE)
```


```{r}
# Check cluster frequencies.
colData(cells)$clusters |>
  table() |>
  sort()
```


```{r}
# Select cells which belong to individuals with progressor status.
cellsToUse <- cells$Status%in%c("nonprogressor", "progressor")

# Perform simple wicoxon rank sum tests on the columns of the proportion matrix.
testProp <- colTest(cells[, cellsToUse], 
                    condition = "Status", 
                    feature = "clusters")

testProp

```

```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

prop <- getProp(cells, feature = "clusters")
clusterToUse <- rownames(testProp)[1]

boxplot( prop[imagesToUse, clusterToUse] ~ clinical[imagesToUse, "Status"] )

```



```{r}

set.seed(51773)
# Perform dimension reduction using UMP.
cells <- scater::runUMAP(cells, 
                         subset_row = useMarkers, 
                         exprs_values = "norm")

# Select a subset of images to plot.
someImages <- unique(colData(cells)$imageID)[c(1,10,20,40,50,60)]

# UMAP by imageID.
scater::plotReducedDim(cells[,colData(cells)$imageID %in% someImages], dimred="UMAP", colour_by="imageID")

# UMAP by cell type cluster.
scater::plotReducedDim(cells[,colData(cells)$imageID %in% someImages], dimred="UMAP", colour_by="clusters")
```




# spicyR: test spatial relationships

```{r}
# Test for changes in pairwise spatial relationships between cell types.
spicyTest <- spicy(cells[, cellsToUse], 
                   condition = "Status", 
                   cellType = "clusters",
                   imageID = "imageID",
                   spatialCoords = c("m.cx", "m.cy"),
                   Rs = c(20, 50, 100),
                   sigma = 50,
                   BPPARAM = BPPARAM)

topPairs(spicyTest, n = 10)

```



```{r}
# Visualise which relationships are changing the most.
signifPlot(spicyTest,
           breaks = c(-1.5, 3, 0.5))


```

# lisaClust: Find cellular neighbourhoods

```{r}
set.seed(51773)

# Cluster cells into spatial regions with similar composition.
cells <- lisaClust(cells, 
                   k = 5, 
                   Rs = c(20, 50, 100),
                   sigma = 50,
                   spatialCoords = c("m.cx", "m.cy"), 
                   cellType = "clusters", 
                   BPPARAM = BPPARAM)

```



```{r}

# Extract cell information and filter to specific image.
df <- colData(cells) |>
as.data.frame() |>
filter(imageID == "Point2206_pt1116_31620")

# Colour cells by their region.
ggplot(df, aes(x = m.cx, y = m.cy, colour = region)) +
  geom_point()

```



```{r}
# Use hatching to visualise regions and cell types.
hatchingPlot(cells,
             useImages = "Point2206_pt1116_31620",
             cellType = "clusters",
             spatialCoords = c("m.cx", "m.cy")
            )
```



```{r}
# Use hatching to visualise regions and cell types.
# Relabel the hatching of the regions.
hatchingPlot(cells,
             useImages = "Point2206_pt1116_31620",
             cellType = "clusters",
             spatialCoords = c("m.cx", "m.cy"),
             window = "square",
             nbp = 300,
             line.spacing = 41) + 
  
  scale_region_manual(values = c(region_1 = 2,
                               region_2 = 1,
                               region_3 = 5,
                               region_4 = 4,
                               region_5 = 3)) + 
  
   guides(colour = guide_legend(ncol = 2))

```




```{r}

# Test if the proportion of each region is associated
# with progression status.
testRegion <- colTest(cells[,cellsToUse], 
                      feature = "region",
                      condition = "Status")

testRegion


```



```{r, fig.height=5, fig.width=5}

# Visualise the enrichment of each cell type in each region
regionMap(cells, cellType = "clusters", limit = c(0.2, 5))

```

# scFeatures: Test some different features

```{r}

# Use scFeatures to calculate proportions and the average marker abundance 
# for each cell type.
data <- scFeatures(cells, 
                   feature_types = c("proportion_raw", "gene_mean_celltype"),
                   sample = "imageID",
                   celltype = "clusters",
                   assay = "norm",
                   ncores = nCores )

names(data) <- c("prop", "mean")


```



```{r}

# Test each marker-celltype for it's association with progression.
test <- colTest(data$mean[imagesToUse,],
                condition = clinical[imagesToUse, "Status"])

test |> head()

```


# ClassifyR: Classification


```{r}

# Add proportions of each region in each image
# to the list of dataframes.
data[["regions"]] <- getProp(cells, "region")

# Subset data images with progression status
measurements <- lapply(data, function(x)x[imagesToUse, ])

# Set seed
set.seed(51773)

# Perform cross-validation of an elastic net model
# with 100 repeats of 5-fold cross-validation.
cv <- crossValidate(measurements = measurements, 
                    outcome = clinical[imagesToUse, "Status"],
                    classifier = "elasticNetGLM",
                    nFolds = 5,
                    nRepeats = 100,
                    nCores = nCores
                    )


# Calculate AUC for each cross-validation repeat and plot.
performancePlot(cv,
                performanceName = "AUC",
                characteristicsList = list(x = "Assay Name"))

```


