---
title: "Performing a spatial analysis of multiplexed tissue imaging data."
author: "Alexander Nicholls and Ellis Patrick"
date: '2022-07-11'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, message = FALSE, warning = FALSE, cache.lazy = FALSE)
```


```{r message=FALSE}
library(cytomapper)
library(dplyr)
library(ggplot2)
library(simpleSeg)
library(FuseSOM)
library(ggpubr)
library(scater)
library(spicyR)
#library(ClassifyR)
library(ClassifyR, lib.loc = "~/localPackages/")
library(scFeatures)
library(lisaClust)

theme_set(theme_classic())
#withr::with_libpaths(new = "~/localPackages/", devtools::install_github("SydneyBioX/ClassifyR"))

```
# Global paramaters
```{r}
nCores <- 20
BPPARAM <- simpleSeg:::generateBPParam(nCores)

```



# Read in images

Our images are stored in the `images` folder within the `Data` folder. Here we use `readImages()` from the `EBImage` package to read these into R. If memory is a restricting factor, and the files are in a slightly different format, you could use `loadImages()` from the `cytomapper` package to load all of the tiff images into a `CytoImageList` object, which can store the images as h5 on-disk.


```{r}

pathToImages <- "Data/images"

# Get directories of images
imageDirs <- dir(pathToImages, full.names = TRUE)
names(imageDirs) <- dir(pathToImages, full.names = FALSE)

# Get files in each directory
files <- sapply(imageDirs, list.files, pattern = "tif", full.names = TRUE, simplify = FALSE)

# Read files with readImage from EBImage
images <- lapply(files, EBImage::readImage, as.is = TRUE)

```

We will make use of the `on_disk` option to convert our images to a `CytoImageList` with the images not held in memory.

```{r}



# Store images in a CytoImageList with images on_disk as h5 files to save memory. 
dir.create("Data/h5Files")
images <- cytomapper::CytoImageList(images, 
                                    on_disk = TRUE, 
                                    h5FilesPath = "Data/h5Files", 
                                    BPPARAM = BPPARAM)
gc()

# images <- cytomapper::loadImages("Data/h5Files/", pattern = "h5", h5FilesPath = "Data/h5Files/",on_disk = TRUE)
# mcols(images) <- S4Vectors::DataFrame(imageID = names(images))
```

# Load the clinical data

## Read the clinical data
```{r}

clinical <- read.csv("Data/1-s2.0-S0092867421014860-mmc1.csv")
clinical <- clinical |>
  mutate(imageID = paste0("Point", PointNumber, "_pt", Patient_ID, "_", TMAD_Patient))
clinical$imageID[grep("normal", clinical$Tissue_Type)] <- paste0(clinical$imageID[grep("normal", clinical$Tissue_Type)], "_Normal")

clinicalVariables <- c("imageID", "Patient_ID","Status", "Age", "SUBTYPE", "PAM50", "Treatment", "DCIS_grade", "Necrosis")
rownames(clinical) <- clinical$imageID

```


## Put the clinical data into the colData of SingleCellExperiment
```{r}

mcols(images) <- clinical[names(images), clinicalVariables]

```






# Segment the images

## Run simpleSeg
```{r}
masks <- simpleSeg(images,
                   nucleus = c("PCA", "HH3"),
                   cellBody = "dilate",
                   transforms = "sqrt",
                   sizeSelection = 40,
                   discSize = 2,
                   cores = nCores)

```


## Visualise separation

```{r}
EBImage::display(colorLabels(masks[[1]]))

```

## Visualise outlines

```{r}
cytomapper::plotPixels(image = images[1:3], 
                       mask = masks[1:3], 
                       img_id = "imageID", 
                       colour_by = c("PanKRT", "GLUT1", "HH3", "CD3", "CD20"), 
                       display = "single",
                       colour = list(HH3 = c("black","blue"), 
                                     CD3 = c("black","purple"),
                                     CD20 = c("black","green"),
                                     GLUT1 = c("black", "red"),
                                     PanKRT = c("black", "yellow")),
                       bcg = list(HH3 = c(0, 1, 1.5), 
                                     CD3 = c(0, 1, 1.5),
                                     CD20 = c(0, 1, 1.5),
                                     GLUT1 = c(0, 1, 1.5),
                                     PanKRT = c(0, 1, 1.5)),
                       legend = NULL)


```


# Summarise cell features.

```{r}

cells <- cytomapper::measureObjects(masks, 
                                    images, 
                                    img_id = "imageID", 
                                    BPPARAM = BPPARAM)

```






# Normalize data


```{r, fig.width=5, fig.height=5}

  df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))

  ggplot(df, aes(x = PanKRT, colour = imageID)) + 
    geom_density() + 
    theme(legend.position = "none")

```



```{r, fig.width=5, fig.height=5}
cells <- normalizeCells(cells, 
                        transformation = "sqrt", 
                        method = c("quant99", "minMax"), 
                        assayIn = "counts", 
                        cores = nCores)


df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))

ggplot(df, aes(x = PanKRT, colour = imageID)) + 
  geom_density() + 
  theme(legend.position = "none")

```



# Cluster cells using FuseSOM package

## Perform the clustering
```{r}
#The markers used in the original publication to gate cell types
useMarkers <- c("PanKRT", "ECAD", "CK7", "VIM", "FAP", "CD31", "CK5", "SMA", 
                "CD45", "CD4", "CD3", "CD8", "CD20", "CD68", "CD14", "CD11c", 
                "HLADRDPDQ", "MPO", "Tryptase")

set.seed(51773)
cells <- runFuseSOM(cells, 
                    markers = useMarkers, 
                    assay = 'norm', 
                    numClusters = 20)

```



## Check how many clusters should be used.
```{r}

# As I've already run runFuseSOM I don't need to run generateSOM()
cells <- estimateNumCluster(cells, kseq = 2:30)
optiPlot(cells, method = "gap")


```


```{r}
scater::plotGroupedHeatmap(cells, 
                           features = useMarkers, 
                           group = "clusters", 
                           exprs_values = "norm",
                           center = TRUE, 
                           scale = TRUE, 
                           zlim = c(-3,3),
                           cluster_rows = FALSE)
```


```{r}
colData(cells)$clusters |>
  table() |>
  sort()
```


```{r}
cellsToUse <- cells$Status%in%c("nonprogressor", "progressor")

testProp <- colTest(cells[, cellsToUse], 
                    condition = "Status", 
                    feature = "clusters")

testProp

```

```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

prop <- getProp(cells, feature = "clusters")
clusterToUse <- rownames(testProp)[1]

boxplot( prop[imagesToUse, clusterToUse] ~ clinical[imagesToUse, "Status"] )

```



```{r}

set.seed(51773)
cells <- scater::runUMAP(cells, 
                         subset_row = useMarkers, 
                         exprs_values = "norm")

someImages <- unique(colData(cells)$imageID)[c(1,10,20,40,50,60)]

# UMAP by imageID
plotReducedDim(cells[,colData(cells)$imageID %in% someImages], dimred="UMAP", colour_by="imageID")

# UMAP by cell type cluster
plotReducedDim(cells[,colData(cells)$imageID %in% someImages], dimred="UMAP", colour_by="clusters")
```




# spicyR: test spatial relationships

```{r}
spicyTest <- spicy(cells[, cellsToUse], 
                   condition = "Status", 
                   cellType = "clusters",
                   imageID = "imageID",
                   spatialCoords = c("m.cx", "m.cy"),
                   Rs = c(20, 50, 100),
                   sigma = 50,
                   BPPARAM = BPPARAM)

topPairs(spicyTest, n = 10)

```



```{r}

signifPlot(spicyTest,
           breaks = c(-1.5, 3, 0.5))


```

# lisaClust: Find cellular neighbourhoods

```{r}
set.seed(51773)
cells <- lisaClust(cells, 
                   k = 7, 
                   Rs = c(20, 50, 100),
                   sigma = 50,
                   spatialCoords = c("m.cx", "m.cy"), 
                   cellType = "clusters", 
                   BPPARAM = BPPARAM)

```



```{r, fig.height= 7, fig.width=9}

  df <- colData(cells) |> 
  as.data.frame() |>
  filter(imageID == "Point2206_pt1116_31620")
  
  ggplot(df, aes(x = m.cx, y = m.cy, colour = region)) +
    geom_point()

    
  # ggplot(df, aes(x = m.cx, y = m.cy, colour = clusters, region = region)) +
  #   geom_point() +
  #   geom_hatching(window = "square", line.spacing = 41) +
  #   scale_region_manual(values = c(region_1 = 1,
  #                                  region_9 = 1,
  #                                  region_10 = 2,
  #                                  region_7 = 2,
  #                                  region_2 = 3,
  #                                  region_3 = 4,
  #                                  region_4 = 4,
  #                                  region_5 = 5,
  #                                  region_8 = 6
  #                                  ))
    


hatchingPlot(cells,
             useImages = "Point2206_pt1116_31620",
             cellType = "clusters",
             spatialCoords = c("m.cx", "m.cy"),
             window = "square",
             nbp = 300,
             line.spacing = 41
            )


```


```{r}

testRegion <- colTest(cells[,cellsToUse], 
                      feature = "region",
                      condition = "Status")

testRegion


```



```{r, fig.height=5, fig.width=5}
regionMap(cells, cellType = "clusters", limit = c(0.2, 5))

```

# scFeatures: Test some different features

```{r}


data <- scFeatures(cells, 
                   feature_types = c("proportion_raw", "gene_mean_celltype"),
                   sample = "imageID",
                   celltype = "clusters",
                   assay = "norm",
                   ncores = nCores )

names(data) <- c("prop", "mean")


```



```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

test <- colTest(data$mean[imagesToUse,],
                condition = clinical[imagesToUse, "Status"])

test |> head()

```


# ClassifyR: Classification


```{r}

data[["regions"]] <- getProp(cells, "region")

data <- lapply(data, as.data.frame)

#Subset data
measurements <- lapply(data, function(x)x[imagesToUse, ])

set.seed(51773)
cv <- crossValidate(measurements = measurements, 
                    outcome = clinical[imagesToUse, "Status"],
                    nFeatures = 5,
                    classifier = "elasticNetGLM",
                    nFolds = 5,
                    nRepeats = 100,
                    nCores = nCores
                    )

ROCplot(cv, comparison = "Assay Name")


performancePlot(cv,
                performanceName = "AUC",
                characteristicsList = list(x = "Assay Name"))

```









<!-- # Check out the published data -->


<!-- ```{r} -->
<!-- im <- read.csv("Single_Cell_Data.csv") -->
<!-- im <- im |> -->
<!--   mutate(imageID = paste0("Point", Point_Num)) -->



<!-- cellCountsMine <- table(cells$imageID) -->
<!-- cellCountsTheirs <- table(im$Point_Num) -->
<!-- names(cellCountsMine) <- unlist(lapply(strsplit(names(cellCountsMine), "_"),function(x)x[1])) -->
<!-- names(cellCountsTheirs) <- paste0("Point", names(cellCountsTheirs)) -->

<!-- plot(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), col = 0) -->
<!-- text(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), names(cellCountsMine)) -->

<!-- abline(0,1) -->


<!-- ``` -->



<!-- ```{r} -->

<!-- convert <- imagesToUse -->
<!-- names(convert) <- unlist(lapply(strsplit(imagesToUse, "_"),function(x)x[1])) -->

<!-- im$imageID <- convert[paste0("Point",im$Point_Num)] -->


<!-- data <- list() -->
<!-- tab <- table(im$imageID, im$phenotype) -->
<!-- tab <- sweep(tab,1,rowSums(tab), "/") -->
<!-- tab <- unclass(tab) -->

<!-- data[["prop"]] <- data.frame(tab[imagesToUse,]) -->



<!-- cv2 <- crossValidate(measurements = data,  -->
<!--                     classes = clinical[imagesToUse, "Status"], -->
<!--                     multiViewMethod = "merge", -->
<!--                     nCores = nCores, -->
<!--                     nFeatures = 10) -->

<!-- label <-  -->

<!-- getAUC <- function(d){ -->
<!--   sapply(split(d@predictions, d@predictions$fold), function(x){ -->
<!--   cvAUC::AUC(x$progressor, clinical[x$sample,"Status"]) -->
<!--     }) -->
<!-- } -->

<!-- perf <- lapply(cv, getAUC) -->
<!-- boxplot(perf) -->





<!-- ``` -->





