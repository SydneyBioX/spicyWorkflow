---
title: "Performing a spatial analysis of multiplexed tissue imaging data."
author: "Alexander Nicholls and Ellis Patrick"
date: '2022-07-11'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, message = FALSE, warning = FALSE, cache.lazy = FALSE)
```


```{r message=FALSE}
library(cytomapper)
library(dplyr)
library(ggplot2)
library(simpleSeg)
library(FuseSOM)
library(ggpubr)
library(scater)
library(spicyR)
#library(ClassifyR)
library(ClassifyR, lib.loc = "~/localPackages/")
library(scFeatures)
library(lisaClust)


#withr::with_libpaths(new = "~/localPackages/", devtools::install_github("SydneyBioX/ClassifyR"))

```
# Global paramaters
```{r}
nCores <- 20
BPPARAM <- simpleSeg:::generateBPParam(nCores)

```



# Read in images

Our images are stored in the `images` folder within the `Data` folder. Here we use `readImages()` from the `EBImage` package to read these into R. If memory is a restricting factor, you could use `loadImages()` from the `cytomapper` package to load all of the tiff images into a `CytoImageList` object, which can store the images as h5 on-disk.


```{r}

pathToImages <- "Data/images"

# Get directories of images
imageDirs <- dir(pathToImages, full.names = TRUE)
names(imageDirs) <- dir(pathToImages, full.names = FALSE)

# Get files in each directory
files <- sapply(imageDirs, list.files, pattern = "tif", full.names = TRUE, simplify = FALSE)

# Read files with readImage from EBImage
images <- lapply(files, EBImage::readImage, as.is = TRUE)

# We've found it useful to sqrt transform our images
images <- lapply(images, sqrt)

```


```{r}



# Store images in a CytoImageList with images on_disk as h5 files to save memory. 
dir.create("Data/h5Files")
images <- CytoImageList(images, on_disk = TRUE, h5FilesPath = "Data/h5Files", BPPARAM = BPPARAM)
mcols(images) <- S4Vectors::DataFrame(imageID = names(images))
gc()

# images <- cytomapper::loadImages("Data/h5Files/", pattern = "h5", h5FilesPath = "Data/h5Files/",on_disk = TRUE)
# mcols(images) <- S4Vectors::DataFrame(imageID = names(images))
```


# Segment the images

## Run simpleSeg
```{r}
masks <- simpleSeg(images,
                   nucleus = c("PCA", "HH3"),
                   cellBody = "dilate",
                   sizeSelection = 40,
                   discSize = 3,
                   cores = nCores)

```


## Visualise separation

```{r}
display(colorLabels(masks[[1]]))

```

## Visualise outlines

```{r}
# img <- CytoImageList(images[1])
# mcols(img) <- S4Vectors::DataFrame(imageID = names(img))
# x = plotPixels(image = normalize(img), mask = masks[1], img_id = "imageID", colour_by = c("CD45", "HH3"), return_images = TRUE)
# display(x$images[[1]])

img <- as.array(images[[1]])
img <- sweep(img, 3, apply(img, 3, max), "/")
mask <- masks[[1]]
cells <- rgbImage(blue=img[,,"HH3"], green=img[,,"CD45"])
cells <- paintObjects(mask, cells, col='#ff00ff')
display(cells, all = TRUE)

```


## Check outlying samples



# Summarise cell features.

```{r}

cells <- cytomapper::measureObjects(masks, 
                                    images, 
                                    img_id = "imageID", 
                                    BPPARAM = BPPARAM)

```



# Load the clinical data

## Read the clinical data
```{r}

clinical <- read.csv("Data/1-s2.0-S0092867421014860-mmc1.csv")
clinical <- clinical |>
  mutate(imageID = paste0("Point", PointNumber, "_pt", Patient_ID, "_", TMAD_Patient))
clinical$imageID[grep("normal", clinical$Tissue_Type)] <- paste0(clinical$imageID[grep("normal", clinical$Tissue_Type)], "_Normal")

clinicalVariables <- c("imageID", "Patient_ID","Status", "Age", "SUBTYPE", "PAM50", "Treatment", "DCIS_grade", "Necrosis")
rownames(clinical) <- clinical$imageID
clinical <- clinical[names(images), ]

```


## Put the clinical data into the colData of SingleCellExperiment
```{r}

colData(cells) <- cbind(colData(cells), clinical[cells$imageID, clinicalVariables])


```



# Normalize data


```{r}

  df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))
  ggplot(df, aes(x = (CD45), colour = imageID)) + geom_density() + theme(legend.position = "none")

```



```{r}

#cells <- normalizeCells(cells, transformation = "sqrt", assayIn = "counts")
source("scMerge2.R")
cells <- normalizeCells(cells, transformation = c("sqrt"), method = c("Mergesc"), assayIn = "counts", cores = nCores)



df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))
 ggplot(df, aes(x = (CD45), colour = imageID)) + geom_density() + theme(legend.position = "none")

```



# Cluster cells using FuseSOM package

## Perform the clustering
```{r}
cells@metadata <- list()
#The markers used in the original publication to gate cell types
useMarkers <- c("PanKRT", "ECAD", "CD45", "CK7", "VIM", "FAP", "CK5", "CD36",
                "CD31", "CD20", "CD4", "CD3", "CD8", "CD14", "CD11c", "CD68",
                "HLADRDPDQ", "SMA")

set.seed(51773)
cells <- runFuseSOM(cells, markers = useMarkers, assay = 'norm', numClusters = 30)

```



## Check how many clusters should be used.
```{r}

# As I've already run runFuseSOM I don't need to run generateSOM()
cells <- estimateNumCluster(cells, kseq = 2:30)
optiPlot(cells)#, method = "silhouette")


```


```{r}
plotGroupedHeatmap(cells, 
                   features = useMarkers, 
                   group = "clusters", 
                   exprs_values = "norm", 
                   center = TRUE, 
                   scale = TRUE, 
                   zlim = c(-2,2))
```


```{r}
sort(table(colData(cells)$clusters))

  

```


```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]
cellsToUse <- cells$Status%in%c("nonprogressor", "progressor")

testProp <- colTest(cells[, cellsToUse], 
                    condition = "Status", 
                    feature = "clusters",
                    type = "ttest")

testProp

```

```{r}

prop <- getProp(cells, feature = "clusters")
clusterToUse <- rownames(testProp)[1]

boxplot( prop[imagesToUse, clusterToUse] ~ clinical[imagesToUse, "Status"] )

```



```{r}

set.seed(51773)
cells <- runUMAP(cells, subset_row = useMarkers, exprs_values = "norm")
plotReducedDim(cells[,colData(cells)$imageID %in% unique(colData(cells)$imageID)[c(c(1,20,40,50,60),c(1,20,40,50,60)+2)]], dimred="UMAP", colour_by="imageID")
plotReducedDim(cells[,colData(cells)$imageID %in% unique(colData(cells)$imageID)[c(c(1,20,40,50,60),c(1,20,40,50,60)+2)]], dimred="UMAP", colour_by="clusters")
```




# spicyR: test spatial relationships

```{r}
spicyTest <- spicy(cells[, cellsToUse], 
                   condition = "Status", 
                   cellType = "clusters",
                   imageID = "imageID",
                   spatialCoords = c("m.cx", "m.cy"),
                   Rs = c(20, 50, 100), 
                   BPPARAM = BPPARAM)
topPairs(spicyTest, n = 10)


```



```{r}

signifPlot(spicyTest)

```

# lisaClust: Find cellular neighbourhoods

```{r}
cells <- lisaClust::lisaClust(cells, k = 7, Rs = c(20,50,100), spatialCoords = c("m.cx", "m.cy"), cellType = "clusters", BPPARAM = BPPARAM)



```



```{r, fig.height= 7, fig.width=9}
df <- as.data.frame(colData(cells))
df <- df[df$imageID == "Point6202_pt1026_20594",]#unique(df$imageID)[2], ]
p <- ggplot(df,aes(x = m.cx, y = m.cy, colour = clusters, region = region)) + 
  geom_point() +
  geom_hatching(window = "square") + 
  scale_region()
p


```


```{r}

imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

prop <- getProp(cells, feature = "region")
testRegion <- colTest(prop[imagesToUse,], condition = clinical[imagesToUse, "Status"])

testRegion
boxplot(prop[imagesToUse,rownames(testRegion)[1]]~clinical[imagesToUse, "Status"])

```



```{r, fig.height=5, fig.width=5}
regionMap(cells, cellType = "clusters", limit = c(0.2,5))
```

# scFeatures: Test some different features

```{r}


data <- scFeatures(cells, 
                   feature_types = c("proportion_raw", "gene_mean_celltype"),
                   sample = "imageID",
                   celltype = "clusters",
                   assay = "norm",
                   ncores = nCores )


```



```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

test <- colTest(data$feature_gene_mean_celltype[imagesToUse,],
        condition = clinical[imagesToUse, "Status"])

tests
```


# ClassifyR: Classification


```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]


data[["regions"]] <- getProp(cells, "region")


set.seed(51773)
cv <- crossValidate(measurements = data, 
                    outcomes = clinical[imagesToUse, "Status"],
                    multiViewMethod = "merge",
                    nCores = nCores,
                    nFeatures = 10,
                    classifier = "elasticNetGLM")

#performancePlot(cv, characteristicsList = list(x = "Classifier Name", fillColour = "characteristicsLabel"))

# getAUC <- function(d){
#   sapply(split(d@predictions, d@predictions$fold), function(x){
#   cvAUC::AUC(x$progressor, clinical[x$sample,"Status"])
#     })
# }
# 
# perf <- lapply(cv, getAUC)
# boxplot(perf)

```


# Check out the published data


```{r}
im <- read.csv("Single_Cell_Data.csv")
im <- im |>
  mutate(imageID = paste0("Point", Point_Num))



cellCountsMine <- table(cells$imageID)
cellCountsTheirs <- table(im$Point_Num)
names(cellCountsMine) <- unlist(lapply(strsplit(names(cellCountsMine), "_"),function(x)x[1]))
names(cellCountsTheirs) <- paste0("Point", names(cellCountsTheirs))

plot(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), col = 0)
text(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), names(cellCountsMine))

abline(0,1)


```



```{r}

convert <- imagesToUse
names(convert) <- unlist(lapply(strsplit(imagesToUse, "_"),function(x)x[1]))

im$imageID <- convert[paste0("Point",im$Point_Num)]


data <- list()
tab <- table(im$imageID, im$phenotype)
tab <- sweep(tab,1,rowSums(tab), "/")
tab <- unclass(tab)

data[["prop"]] <- data.frame(tab[imagesToUse,])



cv2 <- crossValidate(measurements = data, 
                    classes = clinical[imagesToUse, "Status"],
                    multiViewMethod = "merge",
                    nCores = nCores,
                    nFeatures = 10)

label <- 
  
getAUC <- function(d){
  sapply(split(d@predictions, d@predictions$fold), function(x){
  cvAUC::AUC(x$progressor, clinical[x$sample,"Status"])
    })
}

perf <- lapply(cv2, getAUC)
boxplot(perf)





```





