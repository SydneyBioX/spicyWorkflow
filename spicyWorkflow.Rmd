---
title: "Performing a spatial analysis of multiplexed tissue imaging data."
author: "Alexander Nicholls and Ellis Patrick"
date: '2022-07-11'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, message = FALSE, warning = FALSE, cache.lazy = FALSE)
```


```{r message=FALSE}
library(cytomapper)
library(dplyr)
library(ggplot2)
library(simpleSeg)
library(FuseSOM)
library(ggpubr)
library(scater)
library(spicyR)
#library(ClassifyR)
library(ClassifyR, lib.loc = "~/localPackages/")
library(scFeatures)
library(lisaClust)


#withr::with_libpaths(new = "~/localPackages/", devtools::install_github("SydneyBioX/ClassifyR"))

```
# Global paramaters
```{r}
nCores <- 20
BPPARAM <- simpleSeg:::generateBPParam(nCores)

```



# Read in images

Our images are stored in the `images` folder within the `Data` folder. Here we use `readImages()` from the `EBImage` package to read these into R. If memory is a restricting factor, and the files are in a slightly different format, you could use `loadImages()` from the `cytomapper` package to load all of the tiff images into a `CytoImageList` object, which can store the images as h5 on-disk.


```{r}

pathToImages <- "Data/images"

# Get directories of images
imageDirs <- dir(pathToImages, full.names = TRUE)
names(imageDirs) <- dir(pathToImages, full.names = FALSE)

# Get files in each directory
files <- sapply(imageDirs, list.files, pattern = "tif", full.names = TRUE, simplify = FALSE)

# Read files with readImage from EBImage
images <- lapply(files, EBImage::readImage, as.is = TRUE)

# We've found it useful to sqrt transform our images
images <- lapply(images, sqrt)

```

We will make use of the `on_disk` option to convert our images to a `CytoImageList` with the images not held in memory.

```{r}



# Store images in a CytoImageList with images on_disk as h5 files to save memory. 
dir.create("Data/h5Files")
images <- CytoImageList(images, on_disk = TRUE, h5FilesPath = "Data/h5Files", BPPARAM = BPPARAM)
mcols(images) <- S4Vectors::DataFrame(imageID = names(images))
gc()

# images <- cytomapper::loadImages("Data/h5Files/", pattern = "h5", h5FilesPath = "Data/h5Files/",on_disk = TRUE)
# mcols(images) <- S4Vectors::DataFrame(imageID = names(images))
```


# Segment the images

## Run simpleSeg
```{r}
masks <- simpleSeg(images,
                   nucleus = c("PCA", "HH3"),
                   cellBody = "dilate",
                   sizeSelection = 40,
                   discSize = 5,
                   cores = nCores)

```


## Visualise separation

```{r}
display(colorLabels(masks[[1]]))

```

## Visualise outlines

```{r}
plotPixels(image = images[1:3], 
           mask = masks[1:3], 
           img_id = "imageID", 
           colour_by = c("PanKRT", "GLUT1", "HH3", "CD3", "CD20"), 
           display = "single",
           colour = list(HH3 = c("black","blue"), 
                         CD3 = c("black","purple"),
                         CD20 = c("black","green"),
                         GLUT1 = c("black", "red"),
                         PanKRT = c("black", "yellow")),
           legend = NULL)


```


# Summarise cell features.

```{r}

cells <- cytomapper::measureObjects(masks, 
                                    images, 
                                    img_id = "imageID", 
                                    BPPARAM = BPPARAM)

```



# Load the clinical data

## Read the clinical data
```{r}

clinical <- read.csv("Data/1-s2.0-S0092867421014860-mmc1.csv")
clinical <- clinical |>
  mutate(imageID = paste0("Point", PointNumber, "_pt", Patient_ID, "_", TMAD_Patient))
clinical$imageID[grep("normal", clinical$Tissue_Type)] <- paste0(clinical$imageID[grep("normal", clinical$Tissue_Type)], "_Normal")

clinicalVariables <- c("imageID", "Patient_ID","Status", "Age", "SUBTYPE", "PAM50", "Treatment", "DCIS_grade", "Necrosis")
rownames(clinical) <- clinical$imageID
clinical <- clinical[names(images), ]

```


## Put the clinical data into the colData of SingleCellExperiment
```{r}

colData(cells) <- cbind(colData(cells), clinical[cells$imageID, clinicalVariables])


```



# Normalize data


```{r}

  df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))
  ggplot(df, aes(x = (ECAD), colour = imageID)) + geom_density() + theme(legend.position = "none")

```



```{r}

#cells <- normalizeCells(cells, transformation = "sqrt", assayIn = "counts")
#source("scMerge2.R")
cells <- normalizeCells(cells, transformation = c("sqrt"), method = c("perc99"), assayIn = "counts", cores = nCores)



df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))
 ggplot(df, aes(x = (PanKRT), colour = imageID)) + geom_density() + theme(legend.position = "none")

```



# Cluster cells using FuseSOM package

## Perform the clustering
```{r}
cells@metadata <- list()
#The markers used in the original publication to gate cell types
useMarkers <- c("PanKRT", "ECAD", "CD45", "CK7", "VIM", "FAP", "CK5", "CD36",
                "CD31", "CD20", "CD4", "CD3", "CD8", "CD14", "CD11c", "CD68",
                "HLADRDPDQ", "SMA")

set.seed(51773)
cells <- runFuseSOM(cells, markers = useMarkers, assay = 'norm', numClusters = 20)

```



## Check how many clusters should be used.
```{r}

# As I've already run runFuseSOM I don't need to run generateSOM()
cells <- estimateNumCluster(cells, kseq = 2:30)
optiPlot(cells)#, method = "silhouette")


```


```{r}
plotGroupedHeatmap(cells, 
                   features = useMarkers, 
                   group = "clusters", 
                   exprs_values = "norm", 
                   center = TRUE, 
                   scale = TRUE, 
                   zlim = c(-2,2))
```


```{r}
sort(table(colData(cells)$clusters))

  

```


```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]
cellsToUse <- cells$Status%in%c("nonprogressor", "progressor")

testProp <- colTest(cells[, cellsToUse], 
                    condition = "Status", 
                    feature = "clusters",
                    type = "ttest")

testProp

```

```{r}

prop <- getProp(cells, feature = "clusters")
clusterToUse <- rownames(testProp)[1]

boxplot( prop[imagesToUse, clusterToUse] ~ clinical[imagesToUse, "Status"] )

```



```{r}

set.seed(51773)
cells <- runUMAP(cells, subset_row = useMarkers, exprs_values = "norm")
plotReducedDim(cells[,colData(cells)$imageID %in% unique(colData(cells)$imageID)[c(c(1,20,40,50,60),c(1,20,40,50,60)+2)]], dimred="UMAP", colour_by="imageID")
plotReducedDim(cells[,colData(cells)$imageID %in% unique(colData(cells)$imageID)[c(c(1,20,40,50,60),c(1,20,40,50,60)+2)]], dimred="UMAP", colour_by="clusters")
```




# spicyR: test spatial relationships

```{r}
spicyTest <- spicy(cells[, cellsToUse], 
                   condition = "Status", 
                   cellType = "clusters",
                   imageID = "imageID",
                   spatialCoords = c("m.cx", "m.cy"),
                   Rs = c(20, 50, 100),
                   sigma = 50,
                   BPPARAM = BPPARAM)
topPairs(spicyTest, n = 10)


```



```{r}

signifPlot(spicyTest)

```

# lisaClust: Find cellular neighbourhoods

```{r}
cells <- lisaClust(cells, k = 7, Rs = c(20,50,100), sigma = 50,
                   spatialCoords = c("m.cx", "m.cy"), cellType = "clusters", BPPARAM = BPPARAM)



```



```{r, fig.height= 7, fig.width=9}

hatchingPlot(cells,
             useImages = "Point2206_pt1116_31620",
             cellType = "clusters",
             spatialCoords = c("m.cx", "m.cy"),
             window = "square",
             nbp = 200
            )

```


```{r}

imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

prop <- getProp(cells, feature = "region")
testRegion <- colTest(prop[imagesToUse,], condition = clinical[imagesToUse, "Status"])

testRegion
boxplot(prop[imagesToUse,rownames(testRegion)[1]]~clinical[imagesToUse, "Status"])

```



```{r, fig.height=5, fig.width=5}
regionMap(cells, cellType = "clusters", limit = c(0.2,5))
```

# scFeatures: Test some different features

```{r}


data <- scFeatures(cells, 
                   feature_types = c("proportion_raw", "gene_mean_celltype"),
                   sample = "imageID",
                   celltype = "clusters",
                   assay = "norm",
                   ncores = nCores )


```



```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

test <- colTest(data$feature_gene_mean_celltype[imagesToUse,],
        condition = clinical[imagesToUse, "Status"])

test
```


# ClassifyR: Classification


```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]


data[["regions"]] <- getProp(cells, "region")
data <- lapply(data, as.data.frame)

#Subset data
measurements <- lapply(data, function(x)x[imagesToUse, ])
names(measurements) <- c("prop", "mean", "region")

set.seed(51773)
cv <- crossValidate(measurements = measurements, 
                    outcome = clinical[imagesToUse, "Status"],
                    multiViewMethod = "merge",
                    nCores = nCores,
                    nFeatures = 20,
                    classifier = "randomForest")

ROCplot(cv, comparison = "Assay Name")


```


# Check out the published data


```{r}
im <- read.csv("Single_Cell_Data.csv")
im <- im |>
  mutate(imageID = paste0("Point", Point_Num))



cellCountsMine <- table(cells$imageID)
cellCountsTheirs <- table(im$Point_Num)
names(cellCountsMine) <- unlist(lapply(strsplit(names(cellCountsMine), "_"),function(x)x[1]))
names(cellCountsTheirs) <- paste0("Point", names(cellCountsTheirs))

plot(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), col = 0)
text(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), names(cellCountsMine))

abline(0,1)


```



```{r}

convert <- imagesToUse
names(convert) <- unlist(lapply(strsplit(imagesToUse, "_"),function(x)x[1]))

im$imageID <- convert[paste0("Point",im$Point_Num)]


data <- list()
tab <- table(im$imageID, im$phenotype)
tab <- sweep(tab,1,rowSums(tab), "/")
tab <- unclass(tab)

data[["prop"]] <- data.frame(tab[imagesToUse,])



cv2 <- crossValidate(measurements = data, 
                    classes = clinical[imagesToUse, "Status"],
                    multiViewMethod = "merge",
                    nCores = nCores,
                    nFeatures = 10)

label <- 
  
getAUC <- function(d){
  sapply(split(d@predictions, d@predictions$fold), function(x){
  cvAUC::AUC(x$progressor, clinical[x$sample,"Status"])
    })
}

perf <- lapply(cv, getAUC)
boxplot(perf)





```





