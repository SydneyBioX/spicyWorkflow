---
title: "Performing a spatial analysis of multiplexed tissue imaging data."
author: "Alexander Nicholls and Ellis Patrick"
date: '2022-07-11'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```


```{r}
library(cytomapper)
library(dplyr)
library(ggplot2)
library(simpleSeg)
library(FuseSOM)
library(ggpubr)
library(scater)
library(spicyR)
library(lisaClust)
```
# Global paramaters
```{r}
nCores <- 20
BPPARAM <- simpleSeg:::generateBPParam(nCores)

```



# Read in images

Our images are stored in the `images` folder within the `Data` folder. Here we use `readImages()` from the `EBImage` package to read these into R. If memory is a restricting factor, you could use `loadImages()` from the `cytomapper` package to load all of the tiff images into a `CytoImageList` object, which can store the images as h5 on-disk.


```{r}

pathToImages <- "Data/images"

# Get directories of images
imageDirs <- dir(pathToImages, full.names = TRUE)
names(imageDirs) <- dir(pathToImages, full.names = FALSE)

# Get files in each directory
files <- sapply(imageDirs, list.files, pattern = "tif", full.names = TRUE, simplify = FALSE)

# Read files with readImage from EBImage
images <- lapply(files, readImage, as.is = TRUE)


```


```{r}



# Store images in a CytoImageList with images on_disk as h5 files to save memory. 
dir.create("Data/h5Files")
images <- CytoImageList(images, on_disk = TRUE, h5FilesPath = "Data/h5Files", BPPARAM = BPPARAM)
mcols(images) <- S4Vectors::DataFrame(imageID = names(images))

gc()

# images <- cytomapper::loadImages("Data/h5Files/", pattern = "h5", h5FilesPath = "Data/h5Files/",on_disk = TRUE)
# mcols(images) <- S4Vectors::DataFrame(imageID = names(images))
```


# Load the clinical data

```{r}

clinical <- read.csv("Data/1-s2.0-S0092867421014860-mmc1.csv")
clinical <- clinical |>
  mutate(imageID = paste0("Point", PointNumber, "_pt", Patient_ID, "_", TMAD_Patient))

clinicalVariables <- c("imageID", "Patient_ID","Status", "Age", "SUBTYPE", "PAM50", "Treatment", "DCIS_grade", "Necrosis")

rownames(clinical) <- clinical$imageID

clinical <- clinical[names(images), ]

```


# Segment the images

## Normalize the images first

```{r}
images <- cytomapper::normalize(images, separateImages = TRUE, overwrite = TRUE)

```

## Run simpleSeg
```{r}


masks <- simpleSeg(images,
                   nucleus = c("PCA", "HH3"),
                   cellBody = "dilate",
                   sizeSelection = 40,
                   discSize = 3,
                   cores = nCores,
                   tolerance = NULL, 
                   smooth = 1, 
                   ext = 1)

#display(colorLabels(masks[[1]]))


mask <- nucSeg(images[[1]],
               nucleus_index = c("PCA","HH3"),
               size_selection = 40,
               smooth = 1,
               tolerance = NULL,
               watershed = "combine", 
               ext = 1)



masks2 <- BiocParallel::bplapply(images, nucSeg, 
                   nucleus_index = c("PCA","HH3"),
                   size_selection = 40,
                   smooth = 1,
                   tolerance = NULL,
                   watershed = "combine", 
                   ext = 1,
                   BPPARAM = BPPARAM)

masks3 <- CytoImageList(lapply(masks2, Image))
mcols(masks3)$imageID <- names(masks2)

cells <- cytomapper::measureObjects(masks3, 
                                    images, 
                                    img_id = "imageID", 
                                    BPPARAM = simpleSeg:::generateBPParam(cores = nCores))

im <- risom_dat
cellCountsTheirs <- table(im$Point_Num)
names(cellCountsTheirs) <- paste0("Point", names(cellCountsTheirs))

cellCountsMine <- table(colData(cells)$imageID)
names(cellCountsMine) <- unlist(lapply(strsplit(names(cellCountsMine), "_"),function(x)x[1]))

plot(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), col = 0)
text(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), names(cellCountsMine))
abline(0,1)

display(colorLabels(masks[[grep("5302", names(masks))]]))
```


## Visualise separation

```{r}
display(colorLabels(masks[[1]]))

```

## Visualise outlines

```{r}
# img <- CytoImageList(images[1])
# mcols(img) <- S4Vectors::DataFrame(imageID = names(img))
# x = plotPixels(image = normalize(img), mask = masks[1], img_id = "imageID", colour_by = c("CD45", "HH3"), return_images = TRUE)
# display(x$images[[1]])

img <- sqrt(images[[1]])*1.5
mask <- masks[[1]]
cells <- rgbImage(blue=img[,,"HH3"], green=img[,,"CD45"])
cells <- paintObjects(mask, cells, col='#ff00ff')
display(cells, all = TRUE)

```


## Check outlying samples



# Summarise cell features.


```{r}

cells <- cytomapper::measureObjects(masks, 
                                    images, 
                                    img_id = "imageID", 
                                    BPPARAM = BPPARAM)

```


# Normalize data


```{r}

  df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))
  ggplot(df, aes(x = (CD3), colour = imageID)) + geom_density() + theme(legend.position = "none")

```


```{r}

cells <- normalizeCells(cells, transformation = "sqrt", method = c("1stPC"), assayIn = "counts")


df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))
 ggplot(df, aes(x = (CD45), colour = imageID)) + geom_density() + theme(legend.position = "none")


```

```{r}

useMarkers <- c("PanKRT", "ECAD", "CD45", "CK7", "VIM", "FAP", "CK5", "CD36",
                "CD31", "CD20", "CD4", "CD3", "CD8", "CD14", "CD11c", "CD68",
                "HLADRDPDQ", "SMA")

 ggplot(im, aes(x = (CD3), colour = factor(Point_Num))) + geom_density() + theme(legend.position = "none")

res.sce <- runFuseSOM(im, markers = useMarkers, numClusters = 20)


```



```{r}

useMarkers <- rownames(cells)#[!rownames(cells) %in% c("P", "Nuc", "HH3")]


res.sce <- runFuseSOM(cells, markers = useMarkers, assay = 'norm', numClusters = 40)

kseq <- 2:40

k.est.sce <- FuseSOM::estimateNumcluster(cells@metadata$SOM, kseq = kseq)

# plot the Jump statistics

slopes <- k.est.sce$Distance$Slopes
df <- data.frame(Clusters = 1:length(slopes), Slope = slopes)
k.sce.slope <- k.est.sce$Distance$k_Slope
p <- ggpubr::ggline(df, x = "Clusters", y = "Slope", group = 1, color = "steelblue") + 
  geom_vline(xintercept = k.sce.slope, linetype = 2, color = 'steelblue') + 
  labs(y = "Slope statistic (k)", x = "Number of clusters k", 
       title = "Optimal number of clusters using the elbow method")

p
```

```{r}
# lets plot the Jump this time
jumps <- k.est.sce$Distance$Jumps
df <- data.frame(Clusters = 1:length(jumps), Jump = jumps)
k.df.jump <- k.est.sce$Distance$k_Jump
p.df <- ggpubr::ggline(df, x = "Clusters", y = "Jump", group = 1, color = "steelblue") + 
  geom_vline(xintercept = k.df.jump, linetype = 2, color = 'steelblue') + 
  labs(y = "Jump statistic (k)", x = "Number of clusters k", 
       title = "Optimal number of clusters using the elbow method")

p.df
```


```{r}
cells <- runFuseSOM(cells, assay = 'norm', numClusters = 24, markers = useMarkers)
colData(cells)$clusters <- factor(colData(cells)$clusters)

cells <- estimateNumCluster(cells, kseq = 2:30)
optiPlot(cells)


```


```{r}
markerHeatmap(as.data.frame(t(assay(cells, "norm"))), markers = rownames(cells), clusters = factor(colData(cells)$clusters))
```



```{r}
generateHeatmap <- function(data, markers, labels){
  features <- data
  features_heatmap <- aggregate(.~as.character(labels),
                                features[,markers],
                                mean)
  rownames(features_heatmap) <- features_heatmap[,1]
  features_heatmap <- features_heatmap[,-1]
  
  features_heatmap <- sweep(features_heatmap,2, colMeans(features_heatmap), "-")
  features_heatmap <- sweep(features_heatmap,2, apply(features_heatmap,2,sd), "/")
  features_heatmap[features_heatmap>2.5] <- 2.5
  features_heatmap[features_heatmap< -2.5] <- -2.5
  
  annotation_row = data.frame(Clusters = rownames(features_heatmap))
  
  rn <- rownames(features_heatmap)
  features_heatmap <- as.matrix(features_heatmap)
  rownames(features_heatmap) <- rn
  rownames(annotation_row) <- rownames(features_heatmap)
  
  gaps_row <- which(!duplicated(substr(rownames(features_heatmap),1,2)))[-1]-1
  
  p <- ggplotify::as.ggplot(pheatmap::pheatmap(features_heatmap, gaps_row = gaps_row, 
                                     annotation_row = annotation_row, annotation_legend = FALSE, 
                                     cluster_rows = FALSE, cluster_cols = F))
  return(p)
}


p.heat <- generateHeatmap(as.data.frame(t(assay(cells, "norm"))), rownames(assay(cells, "norm")), colData(cells)$clusters)

p.heat <- generateHeatmap(im, useMarkers, res.sce$clusters)

p.heat <- generateHeatmap(im, useMarkers, labels)

p.heat <- markerHeatmap(as.data.frame(t(assay(cells, "norm"))), markers = useMarkers, clusters = colData(cells)$clusters)


labels <- colData(cells)$clusters
data <- as.data.frame(t(assay(cells, "norm")))

data <- data[!labels%in%c("cluster_22", "cluster_23"),]
labels <- labels[!labels%in%c("cluster_22", "cluster_23")]

p.heat <- generateHeatmap(data = data, markers = useMarkers, labels = labels)

```
```{r}
sort(table(colData(cells)$clusters))

```
```{r}
tab <- table(cells$imageID, cells$clusters)
tab <- sweep(tab,2,colSums(tab), "/")



imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

testProp <- apply((tab[imagesToUse,]), 2, function(x){
 test <- t.test(x ~ clinical[imagesToUse, "Status"])
 signif(c(test$estimate, tval <- test$statistic, pval = test$p.value),2)
})

testProp <- as.data.frame(t(testProp))
testProp$cluster <- rownames(testProp)
testProp$adjPval <- signif(p.adjust(testProp$pval, "fdr"),2)
testProp <- testProp[order(testProp$pval),]


boxplot(tab[imagesToUse,rownames(testProp)[1]]~clinical[imagesToUse, "Status"])

```

```{r}

set.seed(51773)
cells <- runUMAP(cells, subset_row = useMarkers, exprs_values = "norm")
plotReducedDim(cells[,colData(cells)$imageID %in% unique(colData(cells)$imageID)[c(1,20,40,50,60)]], dimred="UMAP", colour_by="imageID")
```


```{r}
cells <- lisaClust::lisaClust(cells[, !cells$clusters %in% c("cluster_22", "cluster_23")], k = 10, Rs = c(20,50,100), spatialCoords = c("m.cx", "m.cy"), cellType = "clusters", BPPARAM = BPPARAM)



```
```{r, fig.height= 7, fig.width=9}
df <- as.data.frame(colData(cells))
df <- df[df$imageID == "Point3114_pt1081_31667",]#unique(df$imageID)[2], ]
p <- ggplot(df,aes(x = m.cx, y = m.cy, colour = clusters, region = region)) + 
  geom_point() +
  geom_hatching(window = "square") + 
  scale_region()
p


```


```{r}
tab <- table(cells$imageID, cells$region)
tab <- sweep(tab,2,colSums(tab), "/")



imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

testRegion <- apply((tab[imagesToUse,]), 2, function(x){
 test <- t.test(x ~ clinical[imagesToUse, "Status"])
 signif(c(test$estimate, tval <- test$statistic, pval = test$p.value),2)
})

testRegion <- as.data.frame(t(testRegion))
testRegion$cluster <- rownames(testRegion)
testRegion$adjPval <- signif(p.adjust(testRegion$pval, "fdr"),2)
testRegion <- testRegion[order(testRegion$pval),]
testRegion

boxplot(tab[imagesToUse,rownames(testRegion)[1]]~clinical[imagesToUse, "Status"])

```



```{r}
tab <- table(cells$clusters, cells$region)
tab <- sweep(tab,2,colSums(tab), "/")
round(tab,2)
```



```{r}
as.data.frame(colData(cells)[colData(cells)$imageID == "Point2203_pt1072_31606",]) |>
ggplot(aes(m.cx, m.cy, colour = clusters)) + geom_point()

```

```{r}
im <- read.csv("../../../Downloads/Single_Cell_Data (3).csv")

cellCountsTheirs <- table(im$Point_Num)
names(cellCountsMine) <- unlist(lapply(strsplit(names(cellCountsMine), "_"),function(x)x[1]))
names(cellCountsTheirs) <- paste0("Point", names(cellCountsTheirs))

plot(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), col = 0)
text(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), names(cellCountsMine))
abline(0,1)

x <- readImage("Point2203_labels.tiff")
w <- sapply(unique(x), function(i)colMeans(which(x==i, arr.ind = TRUE)))
```

```{r}
display(colorLabels(masks[[grep("3104",names(masks))]]))
```

