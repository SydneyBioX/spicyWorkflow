---
title: "Performing a spatial analysis of multiplexed tissue imaging data."
author: "Alexander Nicholls and Ellis Patrick"
date: '2022-07-11'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```


```{r message=FALSE}
library(cytomapper)
library(dplyr)
library(ggplot2)
library(simpleSeg)
library(FuseSOM)
library(ggpubr)
library(scater)
library(spicyR)
library(ClassifyR, lib.loc = "~/localPackages/")
library(scFeatures)
library(lisaClust)


#withr::with_libpaths(new = "~/localPackages/", devtools::install_github("SydneyBioX/ClassifyR"))

```
# Global paramaters
```{r}
nCores <- 20
BPPARAM <- simpleSeg:::generateBPParam(nCores)

```



# Read in images

Our images are stored in the `images` folder within the `Data` folder. Here we use `readImages()` from the `EBImage` package to read these into R. If memory is a restricting factor, you could use `loadImages()` from the `cytomapper` package to load all of the tiff images into a `CytoImageList` object, which can store the images as h5 on-disk.


```{r}

pathToImages <- "Data/images"

# Get directories of images
imageDirs <- dir(pathToImages, full.names = TRUE)
names(imageDirs) <- dir(pathToImages, full.names = FALSE)

# Get files in each directory
files <- sapply(imageDirs, list.files, pattern = "tif", full.names = TRUE, simplify = FALSE)

# Read files with readImage from EBImage
images <- lapply(files, readImage, as.is = TRUE)

# We've found it useful to sqrt transform our images
images <- lapply(images, sqrt)

```


```{r}



# Store images in a CytoImageList with images on_disk as h5 files to save memory. 
dir.create("Data/h5Files")
images <- CytoImageList(images, on_disk = TRUE, h5FilesPath = "Data/h5Files", BPPARAM = BPPARAM)
mcols(images) <- S4Vectors::DataFrame(imageID = names(images))
gc()

# images <- cytomapper::loadImages("Data/h5Files/", pattern = "h5", h5FilesPath = "Data/h5Files/",on_disk = TRUE)
# mcols(images) <- S4Vectors::DataFrame(imageID = names(images))
```


# Load the clinical data

```{r}

clinical <- read.csv("Data/1-s2.0-S0092867421014860-mmc1.csv")
clinical <- clinical |>
  mutate(imageID = paste0("Point", PointNumber, "_pt", Patient_ID, "_", TMAD_Patient))
clinical$imageID[grep("normal", clinical$Tissue_Type)] <- paste0(clinical$imageID[grep("normal", clinical$Tissue_Type)], "_Normal")

clinicalVariables <- c("imageID", "Patient_ID","Status", "Age", "SUBTYPE", "PAM50", "Treatment", "DCIS_grade", "Necrosis")

rownames(clinical) <- clinical$imageID

clinical <- clinical[names(images), ]

```


# Segment the images

## Run simpleSeg
```{r}


masks <- simpleSeg(images,
                   nucleus = c("PCA", "HH3"),
                   cellBody = "dilate",
                   sizeSelection = 40,
                   discSize = 3,
                   cores = nCores,
                   tolerance = NULL)

```


## Visualise separation

```{r}
display(colorLabels(masks[[1]]))

```

## Visualise outlines

```{r}
# img <- CytoImageList(images[1])
# mcols(img) <- S4Vectors::DataFrame(imageID = names(img))
# x = plotPixels(image = normalize(img), mask = masks[1], img_id = "imageID", colour_by = c("CD45", "HH3"), return_images = TRUE)
# display(x$images[[1]])

img <- as.array(images[[1]])
img <- sweep(img, 3, apply(img, 3, max), "/")
mask <- masks[[1]]
cells <- rgbImage(blue=img[,,"HH3"], green=img[,,"CD45"])
cells <- paintObjects(mask, cells, col='#ff00ff')
display(cells, all = TRUE)

```


## Check outlying samples



# Summarise cell features.


```{r}

cells <- cytomapper::measureObjects(masks, 
                                    images, 
                                    img_id = "imageID", 
                                    BPPARAM = BPPARAM)

```


<!-- ## Compare to original cells. -->

<!-- It is comforting to see that our segmentation detects a similar number of cells to the segmentation from the manuscript. -->
<!-- ```{r} -->
<!-- im <- risom_dat #From FuseSOM -->
<!-- cellCountsTheirs <- table(im$Point_Num) -->
<!-- names(cellCountsTheirs) <- paste0("Point", names(cellCountsTheirs)) -->

<!-- cellCountsMine <- table(colData(cells)$imageID) -->
<!-- names(cellCountsMine) <- unlist(lapply(strsplit(names(cellCountsMine), "_"),function(x)x[1])) -->

<!-- plot(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), col = 0) -->
<!-- text(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), names(cellCountsMine)) -->
<!-- abline(0,1) -->

<!-- ``` -->


# Normalize data


```{r}

  df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))
  ggplot(df, aes(x = (CD45), colour = imageID)) + geom_density() + theme(legend.position = "none")

```



```{r}

#cells <- normalizeCells(cells, transformation = "sqrt", assayIn = "counts")
cells <- normalizeCells(cells, transformation = NULL, method = c("meandiv"), assayIn = "counts")



df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))
 ggplot(df, aes(x = (CD45), colour = imageID)) + geom_density() + theme(legend.position = "none")

```



<!-- ```{r} -->

<!-- source("scMerge2.R") -->

<!-- #sc merge -->
<!-- use_bpparam <- BiocParallel::MulticoreParam(workers = nCores) -->
<!-- use_bsparam <- BiocSingular::RandomParam() -->
<!-- use_bnparam <- BiocNeighbors::AnnoyParam() -->
<!-- # dat_sub <- dat[sample(nrow(dat), 500000), ] -->
<!-- # ctl_genes <- rownames(sce) -->
<!-- exprsMat <- as.data.frame(assay(cells, "norm")) -->
<!-- batch <- cells$imageID -->
<!-- colnames(exprsMat) <- seq_len(ncol(exprsMat)) -->
<!-- markers <- rownames(cells) -->
<!-- scMerge_res <- scMerge2(exprsMat = exprsMat, #the exprs matrix to be normalised -->
<!--                         batch = batch, # batch labels -->
<!--                         cellTypes = NULL, # set NULL clustering will be performed within scMerge2... can also try the published cell type labels, which will match between the cell types -->
<!--                         use_bpparam = use_bpparam, -->
<!--                         use_bsparam = use_bsparam, -->
<!--                         use_bnparam = use_bnparam, -->
<!--                         ruvK = 2, # Number of unwanted variation to be removed -->
<!--                         ctl = markers, # negative control genes -->
<!--                         k_psuedoBulk = 5, # Number of pseudo bulk to be created for each cell type each batch -->
<!--                         k_celltype = 20, # Number of neighbours when perform graph clustering -->
<!--                         pseudoBulk_fn = create_pseudoBulk, # ways of constructing pseudo bulk -->
<!--                         ncores = nCores, -->
<!--                         chosen.hvg = markers, #Highly variable genes to be used to identify pseudo-replicates... since IMC has very few features, using all features. -->
<!--                         cosineNorm = F, -->
<!--                         return_subset = FALSE, -->
<!--                         normalised = T) -->

<!-- assay(cells, "scMerge2", withDimnames=FALSE) <- t(scMerge_res$newY) -->

<!-- ``` -->

<!-- ```{r} -->
<!-- df <- as.data.frame(cbind(as.data.frame(colData(cells)), t(assay(cells, "scMerge2")))) -->
<!--  ggplot(df, aes(x = (CD45), colour = imageID)) + geom_density() + theme(legend.position = "none") -->

<!-- ``` -->







# Cluster cells using FuseSOM package

## Perform the clustering
```{r}

#The markers used in the original publication to gate cell types
useMarkers <- c("PanKRT", "ECAD", "CD45", "CK7", "VIM", "FAP", "CK5", "CD36",
                "CD31", "CD20", "CD4", "CD3", "CD8", "CD14", "CD11c", "CD68",
                "HLADRDPDQ", "SMA")


cells <- runFuseSOM(cells, markers = useMarkers, assay = 'norm', numClusters = 20)

```



## Check how many clusters should be used.
```{r}

# As I've already run runFuseSOM I don't need to run generateSOM()
cells <- estimateNumCluster(cells, kseq = 2:30)
optiPlot(cells, method = "silhouette")


```


```{r}
plotGroupedHeatmap(cells, 
                   features = useMarkers, 
                   group = "clusters", 
                   exprs_values = "norm", 
                   center = TRUE, 
                   scale = TRUE, 
                   zlim = c(-2,2))
```


```{r}
sort(table(colData(cells)$clusters))

```


```{r}
tab <- table(cells$imageID, cells$clusters)
tab <- sweep(tab,1,rowSums(tab), "/")



imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

testProp <- apply(sqrt(tab[imagesToUse,]), 2, function(x){
 test <- wilcox.test(x ~ clinical[imagesToUse, "Status"])
 signif(c(test$estimate, tval <- test$statistic, pval = test$p.value),2)
})

testProp <- as.data.frame(t(testProp))
testProp$cluster <- rownames(testProp)
testProp$adjPval <- signif(p.adjust(testProp$pval, "fdr"),2)
testProp <- testProp[order(testProp$pval),]
testProp

boxplot(tab[imagesToUse,rownames(testProp)[1]]~clinical[imagesToUse, "Status"])

```

```{r}

set.seed(51773)
cells <- runUMAP(cells, subset_row = useMarkers, exprs_values = "norm")
plotReducedDim(cells[,colData(cells)$imageID %in% unique(colData(cells)$imageID)[c(c(1,20,40,50,60),c(1,20,40,50,60)+2)]], dimred="UMAP", colour_by="imageID")
plotReducedDim(cells[,colData(cells)$imageID %in% unique(colData(cells)$imageID)[c(c(1,20,40,50,60),c(1,20,40,50,60)+2)]], dimred="UMAP", colour_by="clusters")
```




# spicyR: test spatial relationships

```{r}

segCells <- SegmentedCells(colData(cells), spatialCoords = c("m.cx", "m.cy"), cellTypeString = "clusters")
imagePheno(segCells) <- clinical[rownames(segCells),]
spicyTest <- spicy(segCells[imagePheno(segCells)$Status%in%c("nonprogressor", "progressor"),], condition = "Status", Rs = c(20, 50, 100), sigma = 50 )
topPairs(spicyTest, n = 10)
```



```{r}

test <- spicyTest
size <- -log10(test$p.value[,2])
groupA <- test$coefficient[,1]*sqrt(pi)*2/sqrt(10)/100
groupB <- (test$coefficient[,1] + test$coefficient[,2])*sqrt(pi)*2/sqrt(10)/100
cellTypeA <- unlist(lapply(strsplit(rownames(test$statistic), "__"), function(x)x[1]))
cellTypeB <- unlist(lapply(strsplit(rownames(test$statistic), "__"), function(x)x[2]))

df <- data.frame(cellTypeA, cellTypeB, groupA, groupB, size, stat = test$statistic[,2], pvalue = test$p.value[,2], sig = test$p.value[,2] < 0.05)
rownames(df) <- rownames(test$statistic)

library(ggnewscale)

shape.legend = c(NP = "\U25D6", P = "\U25D7")

df.shape = data.frame(cellTypeA = c(NA,NA), cellTypeB = c(NA,NA), size = c(1,1), condition = c("NP", "P"))

ggplot(df, aes(x = cellTypeA, y = cellTypeB, size = size)) + scale_colour_gradient2(low ="#4575B4", mid = "white", high = "#D73027", midpoint = 0, breaks = c(-1.66, -1, 0, 1, 2, 3, 4), labels = c("avoidance", -1, 0, 1, 2, 3, "interaction")) + geom_point(aes(colour = pmin(groupA, 4)), shape="\u25D0") + geom_point(aes(colour = pmin(groupB, 2)), shape="\u25D1") + geom_point(data= df.shape, aes(shape = condition))+ scale_shape_manual(values = shape.legend) +
guides(shape = guide_legend(override.aes = list(size=5))) + labs(colour = "Localisation", shape = "Condition") + new_scale_color() + geom_point(shape=1, aes(colour = factor(sig))) + scale_color_manual(values = c("TRUE" = "black", "FALSE" = "white"), labels = c("p-value < 0.05", "")) + theme_classic() + theme( axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0)) + labs(x = "Cell type i", y = "Cell type j", size = "-log10 p-value", colour = "") +
guides(colour = guide_legend(override.aes = list(size=5)))


```

# lisaClust: Find cellular neighbourhoods

```{r}
cells <- lisaClust::lisaClust(cells, k = 7, Rs = c(20,50,100), spatialCoords = c("m.cx", "m.cy"), cellType = "clusters", BPPARAM = BPPARAM)



```



```{r, fig.height= 7, fig.width=9}
df <- as.data.frame(colData(cells))
df <- df[df$imageID == "Point4106_pt1162_30997",]#unique(df$imageID)[2], ]
p <- ggplot(df,aes(x = m.cx, y = m.cy, colour = clusters, region = region)) + 
  geom_point() +
  geom_hatching(window = "square") + 
  scale_region()
p


```


```{r}
tab <- table(cells$imageID, cells$region)
tab <- sweep(tab,1,rowSums(tab), "/")



imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

testRegion <- apply((tab[imagesToUse,]), 2, function(x){
 test <- wilcox.test(x ~ clinical[imagesToUse, "Status"])
 signif(c(test$estimate, tval <- test$statistic, pval = test$p.value),2)
})

testRegion <- as.data.frame(t(testRegion))
testRegion$cluster <- rownames(testRegion)
testRegion$adjPval <- signif(p.adjust(testRegion$pval, "fdr"),2)
testRegion <- testRegion[order(testRegion$pval),]
testRegion

boxplot(tab[imagesToUse,rownames(testRegion)[1]]~clinical[imagesToUse, "Status"])

```



```{r}
tab <- table(cells$region,cells$clusters)
tab = tab/rowSums(tab)%*%t(colSums(tab))*sum(tab)
ph <- pheatmap::pheatmap(pmin(tab,3))
```

# scFeatures: Test some different features

```{r}

cells$celltype <- cells$clusters
cells$sample <- cells$imageID
assay(cells, "logcounts") <- assay(cells, "norm")
data <- Seurat::as.Seurat(cells)
data@assays$RNA <- data@assays$originalexp
prop <- scFeatures(data, feature_types = c("proportion_raw", "gene_mean_celltype"))

```



```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]


tests <- apply((prop$feature_proportion_raw[imagesToUse,]), 2, function(x){
 test <- wilcox.test(x ~ clinical[imagesToUse, "Status"])
 signif(c(test$estimate, tval <- test$statistic, pval = test$p.value),2)
})

tests <- as.data.frame(t(tests))
tests$cluster <- rownames(tests)
tests$adjPval <- signif(p.adjust(tests$pval, "fdr"),2)
tests <- tests[order(tests$pval),]
tests





tests <- apply((prop$feature_gene_mean_celltype[imagesToUse,]), 2, function(x){
 test <- wilcox.test(x ~ clinical[imagesToUse, "Status"])
 signif(c(test$estimate, tval <- test$statistic, pval = test$p.value),2)
})

tests <- as.data.frame(t(tests))
tests$cluster <- rownames(tests)
tests$adjPval <- signif(p.adjust(tests$pval, "fdr"),2)
tests <- tests[order(tests$pval),]
tests
```


# ClassifyR: Classification


```{r}
imagesToUse <- rownames(clinical)[clinical[, "Status"]%in%c("nonprogressor", "progressor")]

data <- prop
data <- lapply(prop, function(x)x[imagesToUse,])
data <- lapply(data, as.data.frame)


tab <- table(cells$imageID, cells$region)
tab <- sweep(tab,1,rowSums(tab), "/")
tab <- unclass(tab)

data[["regions"]] <- data.frame(tab[imagesToUse,])



cv <- crossValidate(measurements = data, 
                    classes = clinical[imagesToUse, "Status"],
                    multiViewMethod = "merge",
                    nCores = nCores,
                    nFeatures = 10)

performancePlot(cv, characteristicsList = list(x = "Classifier Name", fillColour = "characteristicsLabel"))

getAUC <- function(d){
  sapply(split(d@predictions, d@predictions$fold), function(x){
  cvAUC::AUC(x$progressor, clinical[x$sample,"Status"])
    })
}

perf <- lapply(cv, getAUC)
boxplot(perf)

```


# Check out the published data


```{r}
im <- read.csv("Single_Cell_Data.csv")
im <- im |>
  mutate(imageID = paste0("Point", Point_Num))



cellCountsMine <- table(cells$imageID)
cellCountsTheirs <- table(im$Point_Num)
names(cellCountsMine) <- unlist(lapply(strsplit(names(cellCountsMine), "_"),function(x)x[1]))
names(cellCountsTheirs) <- paste0("Point", names(cellCountsTheirs))

plot(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), col = 0)
text(as.numeric(cellCountsMine), as.numeric(cellCountsTheirs[names(cellCountsMine)]), names(cellCountsMine))

abline(0,1)


```



```{r}

convert <- imagesToUse
names(convert) <- unlist(lapply(strsplit(imagesToUse, "_"),function(x)x[1]))

im$imageID <- convert[paste0("Point",im$Point_Num)]


data <- list()
tab <- table(im$imageID, im$phenotype)
tab <- sweep(tab,1,rowSums(tab), "/")
tab <- unclass(tab)

data[["prop"]] <- data.frame(tab[imagesToUse,])



cv2 <- crossValidate(measurements = data, 
                    classes = clinical[imagesToUse, "Status"],
                    multiViewMethod = "merge",
                    nCores = nCores,
                    nFeatures = 10)

label <- 
  
getAUC <- function(d){
  sapply(split(d@predictions, d@predictions$fold), function(x){
  cvAUC::AUC(x$progressor, clinical[x$sample,"Status"])
    })
}

perf <- lapply(cv2, getAUC)
boxplot(perf)





```





